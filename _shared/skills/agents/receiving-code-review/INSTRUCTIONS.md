# コードレビューの受け取り方

## 概要

コードレビューには技術的な評価が必要であり、感情的なパフォーマンスは不要。

**核心原則:** 実装前に検証する。推測する前に確認する。社会的な快適さより技術的な正確さを優先する。

## 対応パターン

```
コードレビューのフィードバックを受け取った際:

1. 読む: 反応せずに完全なフィードバックを読む
2. 理解する: 要件を自分の言葉で言い換える（または質問する）
3. 検証する: コードベースの実態と照合する
4. 評価する: このコードベースにとって技術的に正しいか？
5. 応答する: 技術的な確認または根拠のある反論
6. 実装する: 一度に一項目ずつ、各項目をテストする
```

## 禁止応答

**絶対にNG:**
- 「おっしゃる通りです！」（CLAUDE.md の明示的な違反）
- 「いいポイントです！」「素晴らしいフィードバックです！」（パフォーマティブ）
- 「今すぐ実装します」（検証前）

**代わりに:**
- 技術的な要件を言い換える
- 明確化の質問をする
- 間違っている場合は技術的な根拠で反論する
- 作業を開始する（行動 > 言葉）

## 不明確なフィードバックの対処

```
いずれかの項目が不明確な場合:
  STOP - まだ何も実装しない
  不明確な項目について明確化を求める

理由: 項目は関連している可能性がある。部分的な理解 = 誤った実装。
```

**例:**
```
ユーザー: 「1〜6を修正して」
あなたは1,2,3,6は理解している。4,5は不明確。

❌ NG: 今1,2,3,6を実装して、後で4,5について質問する
✅ OK: 「1,2,3,6は理解しました。先に進む前に4と5の明確化が必要です。」
```

## ソース別の対応

### ユーザーから
- **信頼できる** - 理解した上で実装する
- **スコープが不明な場合は質問する**
- **パフォーマティブな同意は不要**
- **行動または技術的な確認に移る**

### 外部レビュアーから
```
実装前に:
  1. 確認: このコードベースに技術的に正しいか？
  2. 確認: 既存の機能を壊すか？
  3. 確認: 現在の実装の理由は？
  4. 確認: 全てのプラットフォーム/バージョンで動作するか？
  5. 確認: レビュアーは完全な文脈を理解しているか？

提案が誤っている場合:
  技術的な根拠で反論する

簡単に検証できない場合:
  「[X]なしではこれを検証できません。[調査/質問/続行]すべきですか？」

ユーザーの過去の決定と競合する場合:
  先にユーザーに相談する
```

**ユーザーのルール:** 「外部フィードバック - 懐疑的に、しかし慎重に確認する」

## YAGNIチェック（「適切な実装」への提案）

```
レビュアーが「適切に実装する」と提案した場合:
  コードベースで実際の使用状況を grep する

  未使用の場合: 「このエンドポイントは呼び出されていません。削除する（YAGNI）？」
  使用中の場合: 適切に実装する
```

**ユーザーのルール:** 「あなたとレビュアーの両方が私に報告している。この機能が不要なら追加しないで。」

## 実装順序

```
複数の項目がある場合:
  1. まず不明確なものを全て明確化する
  2. 以下の順で実装する:
     - ブロッキング問題（クラッシュ、セキュリティ）
     - 簡単な修正（タイポ、インポート）
     - 複雑な修正（リファクタリング、ロジック）
  3. 各修正を個別にテストする
  4. リグレッションがないことを確認する
```

## 反論すべき場合

反論が必要なとき:
- 提案が既存の機能を壊す場合
- レビュアーに完全な文脈がない場合
- YAGNI に違反する場合（未使用機能）
- このスタックに技術的に不正確な場合
- レガシー/互換性の理由がある場合
- ユーザーのアーキテクチャ決定と競合する場合

**反論の方法:**
- 感情的にならず技術的な根拠を使う
- 具体的な質問をする
- 動作するテスト/コードを参照する
- アーキテクチャに関わる場合はユーザーを巻き込む

## 正しいフィードバックへの応答

フィードバックが正しい場合:
```
✅ 「修正しました。[何が変わったかの簡単な説明]」
✅ 「いい発見です - [具体的な問題]。[場所]で修正しました。」
✅ [ただコードで修正を示す]

❌ 「おっしゃる通りです！」
❌ 「いいポイントです！」
❌ 「[何かへの]感謝」
❌ いかなる感謝表現も
```

**感謝不要の理由:** 行動で示す。ただ修正する。コード自体がフィードバックを受け取ったことを示す。

**「ありがとう」と書こうとしている場合:** 削除する。代わりに修正内容を述べる。

## 反論が誤りだった場合の対処

反論したが自分が間違っていた場合:
```
✅ 「あなたが正しかった - [X]を確認したら[Y]でした。今すぐ実装します。」
✅ 「これを検証して、あなたが正しいことがわかりました。最初の理解が誤っていた理由は[理由]です。修正中。」

❌ 長い謝罪
❌ 反論した理由の弁明
❌ 過剰な説明
```

## よくある間違い

| 間違い | 修正方法 |
|--------|---------|
| パフォーマティブな同意 | 要件を述べるか、ただ行動する |
| 盲目的な実装 | まずコードベースと照合して検証する |
| テストなしにまとめて実装 | 一度に一項目ずつ、各項目をテストする |
| レビュアーを信頼する | 既存コードを壊すか確認する |
| 反論を避ける | 技術的な正確さ > 快適さ |
| 部分的な実装 | まず全項目を明確化する |
| 検証できないが続行する | 制限を述べ、方向性を求める |

## 実例

**パフォーマティブな同意（NG）:**
```
レビュアー: 「レガシーコードを削除して」
❌ 「おっしゃる通りです！削除します...」
```

**技術的な検証（OK）:**
```
レビュアー: 「レガシーコードを削除して」
✅ 「確認中... ビルドターゲットは10.15+、このAPIは13+が必要。後方互換性のためレガシーが必要。現在の実装はバンドルIDが間違っている - 修正するか、pre-13サポートを廃止するか？」
```

**YAGNI（OK）:**
```
レビュアー: 「データベース、日付フィルター、CSVエクスポート付きの適切なメトリクス追跡を実装して」
✅ 「コードベースをgrep - このエンドポイントを呼び出しているものが見当たらない。削除する（YAGNI）？それとも見逃している使用箇所があるか？」
```

**不明確な項目（OK）:**
```
ユーザー: 「1〜6を修正して」
あなたは1,2,3,6は理解している。4,5は不明確。
✅ 「1,2,3,6は理解しました。実装前に4と5の明確化が必要です。」
```

## GitHub スレッドへの返信

GitHub のインラインレビューコメントに返信する場合は、トップレベルのPRコメントとしてではなく、コメントスレッドに返信すること（`gh api repos/{owner}/{repo}/pulls/{pr}/comments/{id}/replies`）。

## 結論

**外部フィードバック = 評価すべき提案であり、従うべき命令ではない。**

検証する。質問する。それから実装する。

パフォーマティブな同意は不要。常に技術的な厳密さを。
